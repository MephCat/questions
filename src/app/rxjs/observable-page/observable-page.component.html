<h3>
  Объект Subject
</h3>
<p>
  Объекты RxJS Observable создаются либо с
  использованием операторов создания (of, from, fromEvent),
  либо через new Observable.
</p>
<p>
  Пример с оператором of().
</p>
<pre>
  <code>
    of('Hello').subscribe(vl => console.log(vl));
  </code>
</pre>
<p>
  Пример с new Observable.
</p>
<pre>
  <code>
    const obs = new Observable(sub => &#123;
      sub.next(1);

      setTimeout(() => &#123;
         sub.next(3);
         sub.complete();
       &#125;, 500);
    &#125;);

    obs.subscribe(vl => console.log(vl));
  </code>
</pre>
<p>
  Каждый Observable может отправлять своим
  "потребителям" уведомления вызовом одного из трех методов:
</p>
<ul>
  <li>
    <b>next()</b>
    - отправка данных, количество вызовов не ограничено;
  </li>
  <li>
    <b>error()</b>
    - генерация ошибки, параметром указываются данные любого формата
    (строка, объект, исключение) о причине ее возникновения;
  </li>
  <li>
    <b>complete()</b>
    - завершение исполнения Observable, не принимает
    никаких параметров и не передает никакого значения.
  </li>
</ul>
<p>
  Но исполнение RxJS Observable начнется только после
  вызова у него метода subscribe(), который принимает
  функцию с передаваемыми данными в качестве аргумента.
  Вторым и третьим необязательными параметрами методу
  subscribe() можно передать функции,
  которые будут вызваны в случае ошибки или(и) завершения Observable.
</p>
<pre>
  <code>
    const obs = new Observable(sub => &#123;
      sub.next(1);

      setTimeout(() => &#123;
         sub.error(3);
       &#125;, 500);
      &#125;);

    obs.subscribe(
     vl => console.log(vl),
     err => console.log('Error: ', err),
     () => console.log('Completed')
    );
  </code>
</pre>
<p>
  Вызов error() или complete() автоматически завершает исполнение Observable.
</p>
<p>
  Количество вызовов исполнения такого объекта не ограничено,
  а сам он даже не знает, сколько "потребителей" получают от него данные.
</p>
<p>
  Метод subscribe() возвращает объект типа Subscription,
  который хранит текущее исполнение конкретного RxJS Observable
  и имеет единственный метод unsubscribe() для отмены его исполнения.
</p>
<pre>
  <code>
    const sub = obs.subscribe(
     ...
    );

    sub.unsubscribe();
  </code>
</pre>
<p>
  Вызов unsubscribe() нужен только для бесконечно исполняемых Observable,
  иначе занимаемые ими ресурсы будут освобождены только с окончанием
  работы всего приложения. А значит в процессе работы программы может
  произойти утечка памяти или могут быть созданы ненужные дублирующиеся "потребители".
</p>
<p>
  Например, последнее может произойти, когда пользователь зашел на страницу,
  инициирующую исполнение RxJS Observable, затем перешел на другой URL и вернулся обратно.
</p>
<p>
  Бесконечно исполняемыми Observable считаются те из них,
  которые никогда не вызывают метод complete(), даже если
  у них предусмотрен сценарий, при котором произойдет
  обращение к error(), что также завершит исполнение.
</p>
<p>
  В Angular приложении unsubscribe() обычно вызывается
  на стадии жизненного цикла OnDestroy() того компонента, в котором используется Observable.
</p>
